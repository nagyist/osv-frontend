
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - equirectangular panorama demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <link rel="stylesheet" href="lib/bootstrap/css/theme/bootstrap.min.css">
        <link rel="stylesheet" href="lib/openlayers/ol.css">

        <style>
            body {
                margin: 0px;
            }

            header.navbar {
              margin-bottom: 0px;
            }

            #demo {
              margin-left: 0px;
              margin-right: 0px;  
            }

            #demo .col-md-6 {
              padding-left: 0px;
              padding-right: 0px;
            }

            #demo #map {
              height: 500px;
            }

            #demo #osviewer {
                font-size: 0px;
            }

            #wall1 {
                background-color: #2487C1;
                padding: 30px 0px;
                font-size: 20px;
                color: white;
            }

        </style>

        <script src="lib/jquery/jquery-2.1.4.min.js"></script>
        <script src="lib/bootstrap/js/bootstrap.min.js"></script>
        <script src="lib/threejs/three.min.js"></script>
        <script src="lib/openlayers/ol.js"></script>
    </head>
    <body>


        <header class="navbar navbar-default navbar-static-top navbar-inverse" role="navigation">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="#">OpenStreetView.io</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">

              <ul class="nav navbar-nav navbar-right">
                <li><p class="navbar-text text-sm"><span class="glyphicon glyphicon-camera" aria-hidden="true"></span> Currently 2 km mapped!</p></li>
                <li><a href="#">Link</a></li>
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    <li><a href="#">Action</a></li>
                    <li><a href="#">Another action</a></li>
                    <li><a href="#">Something else here</a></li>
                    <li role="separator" class="divider"></li>
                    <li><a href="#">Separated link</a></li>
                  </ul>
                </li>
              </ul>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </header>


        <div id="demo" class="row">
            <div class="col-md-6">
                <div id="map"></div>
            </div>

            <div class="col-md-6">
                <div id="osviewer"></div>
            </div>
        </div>

        
        <div id="wall1" class="row">
            <div class="col-md-6 col-md-offset-3">
                The free and collaborative 360Â° street view of the world
            </div>
        </div>

        

        <script>
          var style = new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: [0, 0, 255, 0.5],
              width: 5
            })
          });

          var vectorSource = new ol.source.Vector({
              url: 'osv.geojson',
              format: new ol.format.GeoJSON()
            });

          var osvLayer = new ol.layer.Vector({
            source: vectorSource,
            style: style
          });

          var map = new ol.Map({
            layers: [
              new ol.layer.Tile({
                source: new ol.source.MapQuest({layer: 'osm'})
              }),
              osvLayer
            ],
            target: 'map',
            controls: ol.control.defaults({
              attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
                collapsible: false
              })
            }),
            view: new ol.View({
              maxZoom: 19,
              center: ol.proj.fromLonLat([2.309241, 48.88711]),
              zoom: 19
            })
          });


          // Basic distance between points, incorrect in long lengths (projection etc)
          var distanceBetweenPoints = function(latlng1, latlng2){
              var line = new ol.geom.LineString([latlng1, latlng2]);
              return Math.round(line.getLength() * 100) / 100;
          };

          // On click on the map, display the closest available pic
          map.on('click', function(evt) {
            displayPicSnap(evt.coordinate);
          });

          var debug = true;
          var debugClosestGeometryLine = null;
          var debugClosestGeometryPoint = null;
          var debugClosestPointLine = null;
          var debugClosestPointPoint = null;
          var displayPicSnap = function(coordinate) {
            // Get the closest line of pics
            var closestFeature = vectorSource.getClosestFeatureToCoordinate(coordinate);
            if (closestFeature != null) {
              // Get the closest point in the line of pics
              var geometry = closestFeature.getGeometry();
              var closestGeometryPoint = geometry.getClosestPoint(coordinate);

              // Get the closest actual pic on the line of pics
              var coordinates = geometry.getCoordinates();
              var closestCoordinateId = 0;
              var minDistance = distanceBetweenPoints(closestGeometryPoint, coordinates[0]);
              for(var i = 1; i < coordinates.length; i++) {
                var distance = distanceBetweenPoints(closestGeometryPoint, coordinates[i]);
                if(distance < minDistance) {
                    closestCoordinateId = i;
                    minDistance = distance;
                }
              }
              var closestGeometryCoordinate = coordinates[closestCoordinateId];
              var picsData = closestFeature.get("pics");
              var picData = picsData[closestCoordinateId];
              console.log(picData);
              


              if(debug) {
                if (debugClosestGeometryPoint === null) {
                  debugClosestGeometryPoint = new ol.geom.Point(closestGeometryPoint);
                } else {
                  debugClosestGeometryPoint.setCoordinates(closestGeometryPoint);
                }
                var coordinates = [coordinate, [closestGeometryPoint[0], closestGeometryPoint[1]]];
                if (debugClosestGeometryLine === null) {
                  debugClosestGeometryLine = new ol.geom.LineString(coordinates);
                } else {
                  debugClosestGeometryLine.setCoordinates(coordinates);
                }

                if (debugClosestPointPoint === null) {
                  debugClosestPointPoint = new ol.geom.Point(closestGeometryCoordinate);
                } else {
                  debugClosestPointPoint.setCoordinates(closestGeometryCoordinate);
                }
                var debugLineCoordinates = [closestGeometryPoint, closestGeometryCoordinate];
                if (debugClosestPointLine === null) {
                  debugClosestPointLine = new ol.geom.LineString(debugLineCoordinates);
                } else {
                  debugClosestPointLine.setCoordinates(debugLineCoordinates);
                }
              }
            }
            map.render();
          };

          if(debug) {
            var imageStyle = new ol.style.Circle({
              radius: 5,
              fill: null,
              stroke: new ol.style.Stroke({
                color: 'rgba(255,0,0,0.9)',
                width: 1
              })
            });
            var strokeStyle = new ol.style.Stroke({
              color: 'rgba(255,0,0,0.9)',
              width: 1
            });
            map.on('postcompose', function(evt) {
              var vectorContext = evt.vectorContext;
              if (debugClosestGeometryPoint !== null) {
                vectorContext.setImageStyle(imageStyle);
                vectorContext.drawPointGeometry(debugClosestGeometryPoint);
              }
              if (debugClosestGeometryLine !== null) {
                vectorContext.setFillStrokeStyle(null, strokeStyle);
                vectorContext.drawLineStringGeometry(debugClosestGeometryLine);
              }
              if (debugClosestPointPoint !== null) {
                vectorContext.setImageStyle(imageStyle);
                vectorContext.drawPointGeometry(debugClosestPointPoint);
              }
              if (debugClosestPointLine !== null) {
                vectorContext.setFillStrokeStyle(null, strokeStyle);
                vectorContext.drawLineStringGeometry(debugClosestPointLine);
              }
            });            
          }

        </script>

        <script>

            var camera, scene, renderer;

            var isUserInteracting = false,
            onMouseDownMouseX = 0, onMouseDownMouseY = 0,
            lon = 0, onMouseDownLon = 0,
            lat = 0, onMouseDownLat = 0,
            phi = 0, theta = 0
            width = window.innerWidth / 2, height = 500;


            init();
            animate();

            function init() {

                var osviewer, mesh;

                osviewer = document.getElementById( 'osviewer' );

                camera = new THREE.PerspectiveCamera( 75, width / height, 1, 1100 );
                camera.target = new THREE.Vector3( 0, 0, 0 );

                scene = new THREE.Scene();

                var geometry = new THREE.SphereGeometry( 500, 60, 40 );
                geometry.scale( - 1, 1, 1 );

                var material = new THREE.MeshBasicMaterial( {
                    map: THREE.ImageUtils.loadTexture( 'img/1.jpg' )
                } );

                mesh = new THREE.Mesh( geometry, material );
                
                scene.add( mesh );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(width, height);
                osviewer.appendChild(renderer.domElement);

                osviewer.addEventListener( 'mousedown', onDocumentMouseDown, false );
                osviewer.addEventListener( 'mousemove', onDocumentMouseMove, false );
                osviewer.addEventListener( 'mouseup', onDocumentMouseUp, false );
                osviewer.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
                osviewer.addEventListener( 'MozMousePixelScroll', onDocumentMouseWheel, false);

                //

                osviewer.addEventListener( 'dragover', function ( event ) {

                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'copy';

                }, false );

                osviewer.addEventListener( 'dragenter', function ( event ) {

                    document.body.style.opacity = 0.5;

                }, false );

                osviewer.addEventListener( 'dragleave', function ( event ) {

                    document.body.style.opacity = 1;

                }, false );

                osviewer.addEventListener( 'drop', function ( event ) {

                    event.preventDefault();

                    var reader = new FileReader();
                    reader.addEventListener( 'load', function ( event ) {

                        material.map.image.src = event.target.result;
                        material.map.needsUpdate = true;

                    }, false );
                    reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

                    document.body.style.opacity = 1;

                }, false );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {
                width = window.innerWidth / 2
                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                renderer.setSize(width, height);
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                isUserInteracting = true;

                onPointerDownPointerX = event.clientX;
                onPointerDownPointerY = event.clientY;

                onPointerDownLon = lon;
                onPointerDownLat = lat;
            }

            function onDocumentMouseMove( event ) {
                if ( isUserInteracting === true ) {
                    lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
                    lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
                }
            }

            function onDocumentMouseUp( event ) {
                isUserInteracting = false;
            }

            function onDocumentMouseWheel( event ) {
                // WebKit
                if ( event.wheelDeltaY ) {
                    camera.fov -= event.wheelDeltaY * 0.05;
                // Opera / Explorer 9
                } else if ( event.wheelDelta ) {
                    camera.fov -= event.wheelDelta * 0.05;
                // Firefox
                } else if ( event.detail ) {
                    camera.fov += event.detail * 0.05;
                }

                camera.updateProjectionMatrix();
            }

            function animate() {
                requestAnimationFrame( animate );
                update();
            }

            function update() {
                lat = Math.max( - 85, Math.min( 85, lat ) );
                phi = THREE.Math.degToRad( 90 - lat );
                theta = THREE.Math.degToRad( lon );

                camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
                camera.target.y = 500 * Math.cos( phi );
                camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

                camera.lookAt( camera.target );

                /*
                // distortion
                camera.position.copy( camera.target ).negate();
                */

                renderer.render( scene, camera );
            }

        </script>
    </body>
</html>
